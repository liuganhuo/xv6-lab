## locks



**矛盾**：通过多处理器并行来提高性能  ->  需要lock来保证正确性，避免race condition  ->   但lock的存在又降低了性能



#### xv6中的lock

通过两个函数进行操作：

- acquire()：确保了只有一个进程获得了lock
- release()：

是否添加lock的判断方式：是否两个进程共享数据结构且一个进程会对其进行写操作

- 但是这并不能覆盖所有情况，如print可能与其他进程交织输出。



##### lock的三种思考视角

1. 可以避免更新丢失
2. 令多步操作具有原子性
3. 维护共享数据结构的不变性



##### lock的常见问题

1. 死锁：可以通过对lock进行排序，按顺序获得lock
2. 破坏了程序的模块化：需要了解调用函数内部的lock情况，这违背了代码的抽象原则。
3. 对性能的影响：



risc-v中特殊的硬件指令确保了lock机制的实现：amoswap

不论是获得lock还是释放lock，都需要这个指令

- ##### 为什么释放的时候不能用load？   因为即使是load也可能不是原子操作，会包含了加载到cache，再从cache中取出的操作，包含了两个微指令



##### memory fence

对于单核cpu来说，通过编译器对指令重排，将critical section内的代码替换到释放锁的句子后面，也是可以正常运行的，因为锁和critical section内的代码没有关联

但是在并法的场景下，是错误的，因此需要禁止对这部分的修改，则需要memory fence (或叫做synchronize指令)。

对于memory fence任何他之前的load/store指令都不能放在他的后面。



